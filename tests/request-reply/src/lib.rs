//! Request/reply guest module used by the end-to-end test harness.

#[cfg(target_arch = "wasm32")]
use anyhow::{Context, Result, anyhow, bail};
#[cfg(target_arch = "wasm32")]
use futures::{SinkExt, StreamExt};
#[cfg(target_arch = "wasm32")]
use selium_userland::{
    abi::GuestResourceId,
    encoding::FlatMsg,
    entrypoint,
    io::{Channel, SharedChannel},
    schema,
};
#[cfg(target_arch = "wasm32")]
use tracing::{info, warn};

/// Flatbuffer bindings generated by the build script.
#[cfg(target_arch = "wasm32")]
#[rustfmt::skip]
#[allow(warnings)]
pub mod fbs;

/// Request payload delivered to the request/reply server.
#[cfg(target_arch = "wasm32")]
#[schema(
    path = "schemas/request_reply.fbs",
    ty = "tests.request_reply.RequestReplyRequest",
    binding = "crate::fbs::tests::request_reply::RequestReplyRequest"
)]
pub struct RequestReplyRequest {
    /// Handle where the request/reply server can attach to the caller's response channel.
    pub response_channel: u64,
    /// Payload to echo back.
    pub msg: String,
}

/// Response payload returned to the request/reply client.
#[cfg(target_arch = "wasm32")]
#[schema(
    path = "schemas/request_reply.fbs",
    ty = "tests.request_reply.RequestReplyResponse",
    binding = "crate::fbs::tests::request_reply::RequestReplyResponse"
)]
pub struct RequestReplyResponse {
    /// Echoed payload.
    pub msg: String,
}

#[cfg(target_arch = "wasm32")]
#[entrypoint]
async fn request_reply_client(server_channel: GuestResourceId) -> Result<()> {
    let response_channel = Channel::create(32 * 1024)
        .await
        .context("create response channel for replies")?;

    let response_share = response_channel
        .share()
        .await
        .context("share response channel")?;

    let req_handle = SharedChannel(server_channel);
    let request_channel = Channel::attach_shared(req_handle)
        .await
        .context("attach to request channel")?;

    let mut publisher = request_channel
        .publish()
        .await
        .context("open request publisher")?;

    let mut replies = response_channel
        .subscribe(32 * 1024)
        .await
        .context("subscribe to response channel")?;

    let request = RequestReplyRequest::new(response_share.raw(), "ping".to_string());
    info!(request_channel = server_channel, "sending ping");
    publisher
        .send(FlatMsg::encode(&request))
        .await
        .context("send request")?;

    match replies.next().await {
        Some(Ok(response)) => {
            let response: RequestReplyResponse =
                FlatMsg::decode(&response.payload).map_err(|e| anyhow!(e))?;
            info!(reply = response.msg, "received echo reply");
        }
        Some(Err(err)) => return Err(err).context("failed to read echo reply"),
        None => bail!("response channel closed before receiving reply"),
    }

    Ok(())
}

#[cfg(target_arch = "wasm32")]
#[entrypoint]
async fn request_reply_server() -> Result<()> {
    let request_channel = Channel::create(32 * 1024)
        .await
        .context("create request channel")?;
    let shared = request_channel
        .share()
        .await
        .context("share request channel")?;

    info!(request_id = shared.raw(), "request/reply server ready");

    let mut requests = request_channel
        .subscribe(32 * 1024)
        .await
        .context("subscribe to requests")?;

    while let Some(frame) = requests.next().await {
        let req: RequestReplyRequest =
            FlatMsg::decode(&frame.context("decode request frame")?.payload)
                .map_err(|e| anyhow!(e))?;
        info!(
            msg = %req.msg,
            response_channel = %req.response_channel,
            "received request"
        );

        let shared = SharedChannel(req.response_channel);
        let response_channel = Channel::attach_shared(shared)
            .await
            .context("attach response channel")?;
        let mut publisher = response_channel
            .publish()
            .await
            .context("open response publisher")?;

        let reply = FlatMsg::encode(&RequestReplyResponse::new(req.msg));
        if let Err(err) = publisher.send(reply).await {
            warn!(
                error = ?err,
                response_channel = req.response_channel,
                "failed to send reply"
            );
        }
    }

    Ok(())
}
