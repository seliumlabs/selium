use anyhow::{Context, Result};
use futures::StreamExt;
use selium_switchboard::{Client, Server, Switchboard};
use tracing::{info, warn};

use selium_userland::{abi::GuestResourceId, entrypoint, io::SharedChannel, schema};

/// Flatbuffer bindings generated by the build script.
#[rustfmt::skip]
#[allow(warnings)]
pub mod fbs;

/// Request payload delivered to the pong server.
#[schema(
    path = "schemas/echo.fbs",
    ty = "examples.echo.EchoRequest",
    binding = "crate::fbs::examples::echo::EchoRequest"
)]
pub struct EchoRequest {
    /// Handle where the pong server can attach to the caller's response channel.
    pub response_channel: u64,
    /// Payload to echo back.
    pub msg: String,
}

/// Response payload returned to the ping client.
#[schema(
    path = "schemas/echo.fbs",
    ty = "examples.echo.EchoResponse",
    binding = "crate::fbs::examples::echo::EchoResponse"
)]
pub struct EchoResponse {
    /// Echoed payload.
    pub msg: String,
}

#[entrypoint]
async fn echo_client(switchboard_channel: GuestResourceId, server_endpoint: u32) -> Result<()> {
    let mut switchboard = Switchboard::attach(SharedChannel(switchboard_channel))
        .await
        .context("attach to switchboard")?;

    let mut client = Client::<EchoRequest, EchoResponse>::create(&mut switchboard)
        .await
        .context("register client endpoint")?;

    client
        .connect(&switchboard, server_endpoint)
        .await
        .context("connect client to server")?;

    // Switchboard handles reply routing; response_channel is unused here.
    let request = EchoRequest::new(0, "ping".to_string());
    info!(server_endpoint, "sending ping");
    let response = client.request(request).await.context("send request")?;
    info!(reply = response.msg, "received echo reply");

    Ok(())
}

#[entrypoint]
async fn echo_server(switchboard_channel: GuestResourceId) -> Result<()> {
    let mut switchboard = Switchboard::attach(SharedChannel(switchboard_channel))
        .await
        .context("attach to switchboard")?;

    let mut server = Server::<EchoRequest, EchoResponse>::create(&mut switchboard)
        .await
        .context("register server endpoint")?;

    info!(server_endpoint = server.endpoint_id(), "echo server ready");

    // Process incoming messages
    while let Some(request) = server.next().await {
        let request = request.context("read request")?;

        info!(
            msg = %request.request().msg,
            response_channel = %request.request().response_channel,
            "received request"
        );

        if let Err(err) = request.reply(EchoResponse::new("pong".into())).await {
            warn!(error = ?err, "failed to send reply");
        }
    }

    Ok(())
}
