//! Edge-to-core web application firewall flow with typed fan-out.

use anyhow::{Context as AnyhowContext, Result};
use futures::{SinkExt, StreamExt};
use selium_atlas::{Atlas, Uri};
use selium_switchboard::{Fanout, Publisher, Subscriber, Switchboard};
use selium_userland::{Context, entrypoint, schema};
use tracing::{info, warn};

/// Flatbuffer bindings generated by the build script.
#[rustfmt::skip]
#[allow(warnings)]
pub mod fbs;

const INGRESS_URI: &str = "sel://edge-waf/ingress";
const OUTCOMES_URI: &str = "sel://edge-waf/outcomes";
const ALERTS_URI: &str = "sel://edge-waf/alerts";
const AUDIT_URI: &str = "sel://edge-waf/audit";

/// Minimal HTTP request metadata captured at the edge.
#[schema(
    path = "schemas/edge_waf.fbs",
    ty = "examples.edge_waf.HttpRequestMeta",
    binding = "crate::fbs::examples::edge_waf::HttpRequestMeta"
)]
pub struct HttpRequestMeta {
    /// Request identifier.
    pub request_id: u64,
    /// HTTP method.
    pub method: String,
    /// Request path.
    pub path: String,
    /// Client IP address.
    pub client_ip: String,
}

/// Verdict produced by edge screening.
#[schema(
    path = "schemas/edge_waf.fbs",
    ty = "examples.edge_waf.Verdict",
    binding = "crate::fbs::examples::edge_waf::Verdict"
)]
pub struct Verdict {
    /// Request identifier.
    pub request_id: u64,
    /// Decision outcome (allow or block).
    pub decision: String,
    /// Decision rationale.
    pub reason: String,
}

/// Alert emitted for suspicious traffic.
#[schema(
    path = "schemas/edge_waf.fbs",
    ty = "examples.edge_waf.SecurityAlert",
    binding = "crate::fbs::examples::edge_waf::SecurityAlert"
)]
pub struct SecurityAlert {
    /// Request identifier.
    pub request_id: u64,
    /// Human-readable summary.
    pub summary: String,
}

/// Audit record emitted for every request.
#[schema(
    path = "schemas/edge_waf.fbs",
    ty = "examples.edge_waf.AuditRecord",
    binding = "crate::fbs::examples::edge_waf::AuditRecord"
)]
pub struct AuditRecord {
    /// Request identifier.
    pub request_id: u64,
    /// Verdict summary.
    pub verdict: String,
}

fn parse_uri(value: &str) -> Result<Uri> {
    Uri::parse(value).with_context(|| format!("parse Atlas URI {value}"))
}

async fn register_endpoint(atlas: &Atlas, uri: &str, endpoint_id: u32) -> Result<()> {
    let parsed = parse_uri(uri)?;
    atlas
        .insert(parsed, endpoint_id as u64)
        .await
        .with_context(|| format!("register Atlas entry for {uri}"))?;
    Ok(())
}

async fn lookup_endpoint(atlas: &Atlas, uri: &str) -> Result<u32> {
    let parsed = parse_uri(uri)?;
    let id = atlas
        .get(&parsed)
        .await
        .with_context(|| format!("lookup Atlas entry for {uri}"))?
        .with_context(|| format!("Atlas entry missing for {uri}"))?;
    Ok(id as u32)
}

fn validate_request(request: &HttpRequestMeta) -> Verdict {
    let blocked = request.path.contains("/admin");
    let (decision, reason) = if blocked {
        ("block", "sensitive path")
    } else {
        ("allow", "ok")
    };

    Verdict::new(request.request_id, decision.to_string(), reason.to_string())
}

#[entrypoint]
async fn edge_ingress_stub(ctx: Context) -> Result<()> {
    let switchboard = ctx.require::<Switchboard>().await;
    let atlas = ctx.require::<Atlas>().await;

    // Publish requests for validation
    let mut publisher = Fanout::<HttpRequestMeta>::create(&switchboard)
        .await
        .context("create request meta publisher")?;
    register_endpoint(&atlas, INGRESS_URI, publisher.endpoint_id()).await?;

    //
    // Simulated HTTP requests entering the WAF
    //
    let requests = [
        HttpRequestMeta::new(
            1001,
            "GET".to_string(),
            "/login".to_string(),
            "203.0.113.9".to_string(),
        ),
        HttpRequestMeta::new(
            1002,
            "POST".to_string(),
            "/admin".to_string(),
            "198.51.100.2".to_string(),
        ),
    ];

    for request in requests {
        info!(
            request_id = request.request_id,
            path = %request.path,
            "edge ingress received request"
        );
        publisher
            .send(request)
            .await
            .context("publish request meta")?;
    }

    Ok(())
}

#[entrypoint]
async fn validate_requests(ctx: Context) -> Result<()> {
    let switchboard = ctx.require::<Switchboard>().await;
    let atlas = ctx.require::<Atlas>().await;

    // Subscribe to HTTP ingress stream
    let mut subscriber = Subscriber::<HttpRequestMeta>::create(&switchboard)
        .await
        .context("create request meta subscriber")?;
    subscriber
        .connect(&switchboard, lookup_endpoint(&atlas, INGRESS_URI).await?)
        .await
        .context("connect to ingress source")?;

    // Publish verdicts to downstream workers
    let mut publisher = Publisher::<Verdict>::create(&switchboard)
        .await
        .context("create verdict publisher")?;
    register_endpoint(&atlas, OUTCOMES_URI, publisher.endpoint_id()).await?;

    while let Some(request) = subscriber.next().await {
        let request = request.context("receive request meta")?;
        let verdict = validate_request(&request);
        info!(
            request_id = verdict.request_id,
            decision = %verdict.decision,
            "edge verdict computed"
        );
        publisher.send(verdict).await.context("publish verdict")?;
    }

    Ok(())
}

#[entrypoint]
async fn result_router(ctx: Context) -> Result<()> {
    let switchboard = ctx.require::<Switchboard>().await;
    let atlas = ctx.require::<Atlas>().await;

    // Subscribe to validation stage
    let mut subscriber = Subscriber::<Verdict>::create(&switchboard)
        .await
        .context("create verdict subscriber")?;
    subscriber
        .connect(&switchboard, lookup_endpoint(&atlas, OUTCOMES_URI).await?)
        .await
        .context("connect to verdict stream")?;

    // Publish alerts for SecOps
    let mut alert_publisher = Publisher::<SecurityAlert>::create(&switchboard)
        .await
        .context("create alert publisher")?;
    register_endpoint(&atlas, ALERTS_URI, alert_publisher.endpoint_id()).await?;

    // Log all requests for auditing
    let mut audit_publisher = Publisher::<AuditRecord>::create(&switchboard)
        .await
        .context("create audit publisher")?;
    register_endpoint(&atlas, AUDIT_URI, audit_publisher.endpoint_id()).await?;

    while let Some(verdict) = subscriber.next().await {
        let verdict = verdict.context("receive verdict")?;
        let audit = AuditRecord::new(verdict.request_id, verdict.decision.clone());
        audit_publisher
            .send(audit)
            .await
            .context("publish audit record")?;

        if verdict.decision == "block" {
            let alert = SecurityAlert::new(
                verdict.request_id,
                format!("blocked request: {}", verdict.reason),
            );
            alert_publisher.send(alert).await.context("publish alert")?;
        }
        info!(request_id = verdict.request_id, "core fan-out complete");
    }

    Ok(())
}

#[entrypoint]
async fn alert_sink(ctx: Context) -> Result<()> {
    let switchboard = ctx.require::<Switchboard>().await;
    let atlas = ctx.require::<Atlas>().await;

    // Subscribe to security alerts
    let mut subscriber = Subscriber::<SecurityAlert>::create(&switchboard)
        .await
        .context("create alert subscriber")?;
    subscriber
        .connect(&switchboard, lookup_endpoint(&atlas, ALERTS_URI).await?)
        .await
        .context("connect to alert stream")?;

    while let Some(alert) = subscriber.next().await {
        let alert = alert.context("receive security alert")?;
        warn!(
            request_id = alert.request_id,
            summary = %alert.summary,
            "received security alert"
        );
    }

    Ok(())
}

#[entrypoint]
async fn audit_sink(ctx: Context) -> Result<()> {
    let switchboard = ctx.require::<Switchboard>().await;
    let atlas = ctx.require::<Atlas>().await;

    // Subscribe to all request results
    let mut subscriber = Subscriber::<AuditRecord>::create(&switchboard)
        .await
        .context("create audit subscriber")?;
    subscriber
        .connect(&switchboard, lookup_endpoint(&atlas, AUDIT_URI).await?)
        .await
        .context("connect to audit stream")?;

    while let Some(record) = subscriber.next().await {
        let record = record.context("receive audit record")?;
        info!(
            request_id = record.request_id,
            verdict = %record.verdict,
            "received audit record"
        );
    }

    Ok(())
}
