use anyhow::{Context, Result, anyhow, bail};
use futures::{SinkExt, StreamExt};
use selium_userland::{
    abi::GuestResourceId,
    encoding::FlatMsg,
    entrypoint,
    io::{Channel, SharedChannel},
    schema,
};
use tracing::{info, warn};

/// Flatbuffer bindings generated by the build script.
#[rustfmt::skip]
#[allow(warnings)]
pub mod fbs;

/// Request payload delivered to the pong server.
#[schema(
    path = "schemas/echo.fbs",
    ty = "examples.echo.EchoRequest",
    binding = "crate::fbs::examples::echo::EchoRequest"
)]
pub struct EchoRequest {
    /// Handle where the pong server can attach to the caller's response channel.
    pub response_channel: u64,
    /// Payload to echo back.
    pub msg: String,
}

/// Response payload returned to the ping client.
#[schema(
    path = "schemas/echo.fbs",
    ty = "examples.echo.EchoResponse",
    binding = "crate::fbs::examples::echo::EchoResponse"
)]
pub struct EchoResponse {
    /// Echoed payload.
    pub msg: String,
}

#[entrypoint]
async fn echo_client(server_channel: GuestResourceId) -> Result<()> {
    // Create RPC response channel
    let response_channel = Channel::create(32 * 1024) // 32kb
        .await
        .context("create response channel for replies")?;

    let response_share = response_channel
        .share()
        .await
        .context("share response channel")?;

    let req_handle = SharedChannel(server_channel);

    let request_channel = Channel::attach_shared(req_handle)
        .await
        .context("attach to request channel")?;

    // Create sender & receiver handles
    let mut publisher = request_channel
        .publish()
        .await
        .context("open request publisher")?;

    let mut replies = response_channel
        .subscribe(32 * 1024) // 32kb
        .await
        .context("subscribe to response channel")?;

    // Send request
    let request = EchoRequest::new(response_share.raw(), "ping".to_string());
    info!(echo_server = server_channel, "sending ping");
    publisher
        .send(FlatMsg::encode(&request))
        .await
        .context("send request")?;

    // Receive response
    match replies.next().await {
        Some(Ok(response)) => {
            let response: EchoResponse =
                FlatMsg::decode(&response.payload).map_err(|e| anyhow!(e))?;
            info!(reply = response.msg, "received echo reply");
        }
        Some(Err(err)) => return Err(err).context("failed to read echo reply"),
        None => bail!("response channel closed before receiving reply"),
    }

    Ok(())
}

#[entrypoint]
async fn echo_server() -> Result<()> {
    // Create incoming request channel
    let request_channel = Channel::create(32 * 1024)
        .await
        .context("create request channel")?; // 32kb
    let shared = request_channel
        .share()
        .await
        .context("share request channel")?;

    info!(request_id = shared.raw(), "echo server ready");

    // Create receiver handle
    let mut requests = request_channel
        .subscribe(32 * 1024)
        .await
        .context("subscribe to requests")?;

    // Process incoming messages
    while let Some(frame) = requests.next().await {
        let req: EchoRequest = FlatMsg::decode(&frame.context("decode request frame")?.payload)
            .map_err(|e| anyhow!(e))?;
        info!(msg = %req.msg, response_channel = %req.response_channel, "received request");

        // Connect to client response channel
        let shared = SharedChannel(req.response_channel);
        let response_channel = Channel::attach_shared(shared)
            .await
            .context("attach response channel")?;
        let mut publisher = response_channel
            .publish()
            .await
            .context("open response publisher")?;

        // Send response
        let reply = FlatMsg::encode(&EchoResponse::new(req.msg));
        if let Err(err) = publisher.send(reply).await {
            warn!(
                error = ?err,
                response_channel = req.response_channel,
                "failed to send reply"
            );
        }
    }

    Ok(())
}
