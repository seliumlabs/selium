use anyhow::{Context, Result};
use futures::TryStreamExt;
use selium_atlas::{Atlas, Uri};
use selium_switchboard::{Client, Server, Switchboard};
use selium_userland::{entrypoint, schema};
use tracing::info;

/// Flatbuffer bindings generated by the build script.
#[rustfmt::skip]
#[allow(warnings)]
pub mod fbs;

/// Request payload delivered to the pong server.
#[schema(
    path = "schemas/echo.fbs",
    ty = "examples.echo.EchoMsg",
    binding = "crate::fbs::examples::echo::EchoMsg"
)]
pub struct EchoMsg {
    /// Your message to echo
    pub msg: String,
}

#[entrypoint]
async fn echo_client(ctx: selium_userland::Context) -> Result<()> {
    let switchboard = ctx.require::<Switchboard>().await;
    let atlas = ctx.require::<Atlas>().await;

    let server_endpoint = atlas
        .get(&Uri::parse("sel://moo/cow").unwrap())
        .await?
        .unwrap() as u32;

    let mut client = Client::create(&switchboard).await?;
    client.connect(&switchboard, server_endpoint).await?;

    let request = EchoMsg::new("Hello, world!".to_string());
    info!("sending message");
    let response: EchoMsg = client.request(request).await.context("send request")?;
    info!(reply = response.msg, "received echo");

    Ok(())
}

#[entrypoint]
async fn echo_server(ctx: selium_userland::Context) -> Result<()> {
    let switchboard = ctx.require::<Switchboard>().await;
    let atlas = ctx.require::<Atlas>().await;

    let server: Server<EchoMsg, EchoMsg> = Server::create(&switchboard).await?;
    atlas
        .insert(
            Uri::parse("sel://moo/cow").unwrap(),
            server.endpoint_id() as u64,
        )
        .await?;
    server
        .try_for_each(async |req| {
            let (msg, responder) = req.into_parts();
            info!(msg = msg.msg, "received request");

            responder.send(msg).await
        })
        .await?;

    Ok(())
}
